#!/usr/bin/python3

#Authors: 
# Paulo Ricardo Garcia, paulo.garcia@lnls.br
# Joao Paulo Castro Zerba, joao.zerba@lnls.br
# Software to perform azimuthal integration of scattering images using pyFAI python library.
#Date: 22/11/2021


from PyQt5 import QtCore, QtWidgets, QtGui# QtCore.QThread e QtCore.pyqtSignal
from PyQt5.QtCore import QThread, pyqtSignal
from PyQt5.QtWidgets import (
    QWidget, QFileDialog, QMessageBox, QPushButton, QVBoxLayout, QFileDialog, QTableWidget,
    QApplication, QLabel, QCheckBox, QGroupBox, QScrollArea, QHBoxLayout, QVBoxLayout, 
    QGridLayout, QLineEdit)
from PyQt5 import uic
import sys, glob,matplotlib,  os, h5py

from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar
import matplotlib.pyplot as plt
import numpy as np
import fabio
from os.path import expanduser
import webbrowser

#======================== Folders ====================================# Working Folder
# Folder path needs to be changed when deploying this app to another machine/local.
FOLDER_PATH = '.'
# Folder path where the integration module that uses pyFAI is located.
PYFAI_FOLDER = 'PyFAI_Interface'
# Folder path where the plot module with the rgb codes is located.
PLOT_WINDOW_FOLDER = 'Utils'
# Folder path where the the pdf guide is located.
GUIDE_FOLDER = 'Utils/guide'
# Folder where the saved HDF result
HDF_FOLDER = expanduser("~") + "/Integrated"
# Folder where the dat files generated by the pyFAI is saved.
DAT_FOLDER = HDF_FOLDER + "/Dat_Files"
# Folder where the flipped msk files are saved.
MSK_FOLDER = HDF_FOLDER + "/Flipped_Fit2D_MSKs"
#=====================================================================#

# Making the following folders visible for python to import the modules inside of them.
sys.path.append(FOLDER_PATH + '/' + PYFAI_FOLDER)
sys.path.append(FOLDER_PATH + '/' + PLOT_WINDOW_FOLDER)

import pyFAI_Integrate
import RGB_codes

# Global dictionary for the integration app
Int_data = {}


class WorkerThread(QtCore.QThread):


    '''Class to handle the pyFAI calculations in a separated processing thread.
       Signals are sent to MainWindow class GUI to update the progress bar
       and the plot list.
    '''

    def __init__(self, dict_params, pushButton_stop, pushButton_stop_batch, flip_msk):
        super().__init__()

        # Init the qthread state to pause or stop the integration.
        self.is_paused = False
        self.is_killed = False

        # Init the parameters of the integration.
        self.dict_params = dict_params  

        # Calling the global var DAT_Folder to inside the class.
        global DAT_FOLDER

        # Evoking the pyFAI module to perform the integration.
        self.pyFAI = pyFAI_Integrate.PyFAI_interface(self.dict_params, DAT_FOLDER, flip_msk)

        # Linking the stop button to the stop event (could be put in MainWindow and send
        # signal from Qthread).
        pushButton_stop.clicked.connect(self.stop)
        pushButton_stop_batch.clicked.connect(self.stop)

    # Following signals the Qthread class will send to GUI.
    # Updates the progress bar widgets
    update_progress = pyqtSignal(list)
    plot_data_list = pyqtSignal(list)
    		
    def run(self):
        # Calling the global var Int_data to inside the class.
        global Int_data

        # Getting all file names  to be integrated.
        File_list = self.dict_params["datafile"]
         
        for i in range(len(File_list)):   
            # Full path.
            file_path = self.pyFAI.folder_path + '/' + File_list[i]
            # Getting the filename.
            file_name, Ext = os.path.splitext(File_list[i])

            # Counting the number of files to be integrated.
            ninter = self.Count_integrations(self.pyFAI.images_interval[i])
            # Updating the filename label that appears above the progress bar.
            updt_label = i
            # Checking dimmesion for HDF and npy files.
            ndim = self.pyFAI.Check_hdf_dimm(file_path, self.pyFAI.hdf_group)
            # Starting the progress bar with value 0 for each integration file.
            self.bar_emitter([int(0),int(updt_label)])       



            # Initializing the progress bar counter
            counter = 0
            for interval in self.pyFAI.images_interval[i]:
                # Enabling the stop at this part.
                if self.is_killed == True:
                    print("Break 01")
                    break

                # If all images are going to be integrated and single image ndim = 2. Just one Img.
                if interval == -1 and ndim == 2:
                    # File of one image.
                    NImg = 1
                    # Calling module for pyFAI to integrate. 0 neglect the image index for one image.
                    self.pyFAI.Call_pyfai( 0, file_name, file_path, self.pyFAI.scatt, self.pyFAI.Mask_Arr, ndim)
                    # Updating the progress bar counter.
                    counter +=1
                    # Transforming the progress bar value in percentage.
                    b_percentage=100*counter/(NImg)
                    # Emitting the progress bar value for Main GUI window.
                    self.bar_emitter([int(b_percentage),int(updt_label)])                

                # If all images are going to be integrated but with ndim different of 2.
                elif interval  == -1 and ndim != 2:
                    # Calling module for pyFAI to check size of HDF and npy file.
                    NImg = self.pyFAI.Hdf_Size(file_path, self.pyFAI.hdf_group)
                    # Enabling the stop at this part.
                    for j in range(NImg):
                        if self.is_killed == True:
                            print("Break 02")
                            break
                        # Calling module for pyFAI to integrate.
                        self.pyFAI.Call_pyfai(j, file_name, file_path, self.pyFAI.scatt, self.pyFAI.Mask_Arr, ndim)
                        # Updating the progress bar counter.
                        counter +=1
                        # Transforming the progress bar value in percentage.
                        b_percentage=100*counter/(NImg)
                        # Emitting the progress bar value for Main GUI window.
                        self.bar_emitter([int(b_percentage),int(updt_label)])

                # If not all images will be integrated.
                else:
                    # Enabling the stop at this part.
                    if self.is_killed == True:
                        print("Break 03")
                        break
                    # Just one interval (slice).
                    if len(interval) == 1:
                        # Calling module for pyFAI to integrate.
                        self.pyFAI.Call_pyfai( interval[0], file_name, file_path, self.pyFAI.scatt, self.pyFAI.Mask_Arr,ndim)
                        # Updating the progress bar counter.
                        counter +=1
                        # Transforming the progress bar value in percentage.
                        b_percentage=100*counter/ninter
                        # Emitting the progress bar value for Main GUI window.
                        self.bar_emitter([int(b_percentage),int(updt_label)])
                    
                    # Same image.
                    elif len(interval) == 2 and interval[0]==interval[1]:
                        # Enabling the stop at this part.
                        if self.is_killed == True:
                            print("Break 4")
                            break
                        # Calling module for pyFAI to integrate.
                        self.pyFAI.Call_pyfai( interval[0], file_name, file_path, self.pyFAI.scatt, self.pyFAI.Mask_Arr,ndim)
                        # Updating the progress bar counter.
                        counter +=1
                        # Transforming the progress bar value in percentage.
                        b_percentage=100*(counter)/ninter
                        # Emitting the progress bar value for Main GUI window.
                        self.bar_emitter([int(b_percentage),int(updt_label)])

                    else:
                        # For multiple intervals 
                        for j in range(interval[0], interval[1] + 1):
                            # Enabling the stop at this part.
                            if self.is_killed == True: #To try to stop worker thread
                                print("Break 5")
                                break
                            # Calling module for pyFAI to integrate.
                            self.pyFAI.Call_pyfai( j, file_name, file_path, self.pyFAI.scatt, self.pyFAI.Mask_Arr,ndim)
                            # Updating the progress bar counter.
                            counter +=1
                            # Transforming the progress bar value in percentage.
                            b_percentage=100*counter/ninter
                            # Emitting the progress bar value for Main GUI window.
                            self.bar_emitter([int(b_percentage),int(updt_label)])
            
        # Building the Int_data dictionary which will store all the integration data.
        for i in range(len(self.pyFAI.Output_names)): 
            # filename now is the filename of the incremented images in the file.
            filename, ext = os.path.splitext(self.pyFAI.Output_names[i])
            # It is exported for each image, the q, intensity, std dev, and the dict_params.
            Int_data[filename] = [self.pyFAI.q[i], self.pyFAI.Iq[i], self.pyFAI.std[i],self.dict_params]
                     
        # Emitting the plot data list to Main GUI window.
        self.plot_data_list.emit([self.pyFAI.radial_unity, Int_data])

        return 

    def Count_integrations(self, img_arrays):
    # Function to count the number of images to be integrated
        N= 0
        
        if img_arrays[0] == -1:
            N = -1
        else:
            for element in img_arrays:
                if len(element) == 2:
                    N += abs(element[1] - element[0]) + 1

                else:
                    N+=1

            return N


    # Method to emmit the progress value for the bar.
    def bar_emitter(self, x):
        self.update_progress.emit(x)
    # Method to stop the thread loop.
    def stop(self):
        self.is_killed = True
    # Method used to stop from GUI.
    def call_stop(self):
        self.pyFAI.stop()
  

Ui_Form, QtBaseClass = uic.loadUiType(FOLDER_PATH + '/' + 'saxs-gui.ui')


class MainWindow(QtWidgets.QWidget, Ui_Form):
    '''
        Class responsible for the GUI - Graphical User Interface.
        it talks to a Qthread for looping calculations regarding 
        pyFAI integrations.
    '''
    def __init__(self, parent = None):
        super(MainWindow, self).__init__(parent)
        super(Ui_Form,self).__init__()
        self.setupUi(self)

        # Enabling buttons connections.
        self.setFrontButtons()
    
        # Poni starts unchecked - setting hidden for third angle.
        self.label_tilt3.setHidden(True)
        self.lineEdit_tilt3.setHidden(True)

        # Starting geometric labels.
        self.setGeomLabels()
        self.flip_msk = False
        # Creating a pyFAI object to read the poni files to update the GUI.
        self.pyfai_poni = pyFAI_Integrate.PyFAI_interface('For Poni Loader','', self.flip_msk)
        self.groupBox_ponifile.toggled.connect(self.onPoniGroupBoxToggled)

        # Methods responsible for the dynamic lists in batch mode.
        # Method responsible for listing the filenames in the list widget.
        self.listFiles()
        # Method to update the buttons to add and remove filenames in the list widgets.
        self.updateButtonStatus()
        # Enabling buttons connections
        self.setButtonConnections()
        # Method set the double clicked feature for the itens in the list widgets.
        self.setItemDoubleClicked()
        # Method that clears the list widgets and updates the filenames upon changin the folder path.
        self.onFolderChangeUpdtList() 
                
        # Plot.
        self.fig_width = 400
        self.fig_height = 400
        self.xscale = False
        self.yscale = False
        # Initializing the plot window.
        self.init_pyplot_graph()
        # Initializing the plot buttons.
        self.init_plot_buttons()
        # Importing the RGB codes to a class object.
        self.colors = RGB_codes.Import_colors()
        
    ##Integration
    def setGeomLabels(self):
    # Labels for the geometry field.
        self.geom_labels = [
        ['Samp-Det Distance (m)','Samp-Det Distance (m)'],
        ['Wavelength (Å)','Wavelength (Å)'],
        ['Y-Center (px)','Poni1 (m)'],
        ['X-Center (px)','Poni2 (m)'],
        ['X-Pixel Size (μm)','Pixel Size 2 (μm)'],
        ['Y-Pixel Size (μm)','Pixel Size 1 (μm)'],
        ['Tilt (dg)','Rot1 (rad)'],
        ['Tilt Plan Rot (dg)','Rot2 (rad)'],
        ['Rot3 (rad)','Rot3 (rad)'],
        ]

    ##Integration
    def setFrontButtons(self):

        ##Set Work Folder button
        self.pushButton_folderpath.clicked.connect(self.search_choose_dir)
        ##Set Search Data button
        self.pushButton_datafilepath.clicked.connect(lambda: self.getFilename('datafile'))
        ##Set Search Mask button
        self.pushButton_maskfile.clicked.connect(lambda: self.getFilename('maskfile'))
        ##Set search poni
        self.pushButton_selectponifile.clicked.connect(lambda: self.getFilename('ponifile'))
        ##Set Editable Poni Path to load Poni Params
        self.lineEdit_ponifile.returnPressed.connect(self.poniLoader)
        ##Set search spline
        self.pushButton_splinefile.clicked.connect(lambda: self.getFilename('splinefile'))
        ##Set start integration button
        self.pushButton_start.clicked.connect(self.single_launch)
        ##Batch mode integration button
        self.pushButton_batch_int.clicked.connect(self.batch_launch)
        ##Set stop integration button
        #self.pushButton_stop.clicked.connect(self.pyFAI_Integrate.PyFAI_interface.stop)
        #self.pushButton_stop.clicked.connect(self.stopBtnFunc)
        self.help_button.clicked.connect(self.open_guide)
    
    def open_guide(self):
        global FOLDER_PATH
        global GUIDE_FOLDER
        webbrowser.open_new(FOLDER_PATH + "/" + GUIDE_FOLDER + "/Azimuthor_Guide.pdf")

        # Works but check compat and permission error
        #os.system("evince " + GUIDE_FOLDER + "/Azimuthor_Guide.pdf &")


    ##Integration
    def folderCheck(self, folderpath, popup):
        ##Check if folder is valid
        ##TODO - Do we care about overwriting output results!?

        #folderpath = self.lineEdit_folderpath.text()
        if os.path.exists(folderpath) == False:
            invalid = 1
            if popup:
                self.popupbox("Provided path for the Work Folder is invalid.\nPlease choose a new folder.")
        else:
            ##Support check to avoid overwrites
            invalid = 0

        return invalid

    ##Integration
    def filenameCheck(self, folder_path, file_path, file):
        # Check if file path is valid.
        if os.path.isfile(folder_path +"/"+ file_path) == False:
            invalid = 1
            self.popupbox('Provided filename for ' + file + ' is invalid.\n Please choose a new file.')
        else:
            invalid = 0

        return invalid

    ##Integration
    def popupbox(self,message):
        # System generic message box.
        msg = QMessageBox(self)
        msg.setIcon(QMessageBox.Information)
        msg.setText(message)
        msg.setWindowTitle("Attention!")
        msg.exec_()
    
    def hdf_check(self, filepath):
		#Checking if the hdf file is readable 
         hdf_group = self.lineEdit_hdfgrouppath.text()
         return self.pyfai_poni.Check_hdf_dimm(filepath, hdf_group)

    def hdf_read_check(self, filepath):
		#Checking if the hdf file is readable. If it is not
		# a window pops up and warn the user 
        try:
            read_val = self.hdf_check(filepath)
            if read_val == -1:
                self.popupbox('Could not read the hdf file! Invalid group!')
                return 1
            else:
                return 0

        except Exception as e:
            self.popupbox('Could not read the hdf file! Invalid group! ', e)
            return 1


    ##Integration
    def validator(self, mask_path, mask_file, folder_path, data_name):
        # Validation method before starting the integration.
        # if invalid == 1 means invalid, 0 means valid.

        folder_invalid = self.folderCheck(folder_path, True)
        datafile_invalid = self.filenameCheck(folder_path, data_name, 'data')
        maskfile_invalid = self.filenameCheck(mask_path, mask_file, 'maskfile')

        if folder_invalid and datafile_invalid == 0:
            datafile_read_invalid = self.hdf_read_check(folder_path + "/"+ data_name )
        else:
            datafile_read_invalid =0
        
        
        if self.groupBox_ponifile.isChecked() == True:
            ponifile_invalid = self.filenameCheck("", self.lineEdit_ponifile.text(), 'ponifile')
        else:
            ponifile_invalid = 0

        if self.groupBox_spline.isChecked() == True:
            splinefile_invalid = self.filenameCheck("", self.lineEdit_splinefile.text(), 'splinefile')
        else:
            splinefile_invalid = 0

        # If the sum is not zero, it can't start the integration
        scan_valid = (folder_invalid + datafile_invalid + maskfile_invalid + ponifile_invalid + splinefile_invalid + datafile_read_invalid)

        return scan_valid

    ##Integration
    def batch_launch(self):
        # Batch mode launch method
        
        batch_list = self.chosenBatchFiles()
        img_range = self.chosenRangeLines()
        bugged_img_str = []
    	
        # Checking if the strings for the intervals is properly written,
        # if not, a message box will display indicating the lines in the interval 
        # list widget that needs attention.
        for i in range(len(img_range)):
    		
            if self.Check_string(img_range[i]) == False:
                bugged_img_str.append(i+1)

        # Plural warning.
        if len(bugged_img_str) > 1:

            popup_str = ""
            for i in range(len(bugged_img_str) -1):
                popup_str += str(bugged_img_str[i]) + ","
            popup_str += " and " + str(bugged_img_str[-1])
            self.popupbox("Invalid string at lines "+ popup_str + " of the Image Range field")
        # Singular warning.
        elif len(bugged_img_str) == 1:
            self.popupbox("Invalid string at line "+ str(bugged_img_str[0]) + " of the Image Range field"  )
    	# All right to go to launch method.
        else:
            hdf_path = self.lineEdit_hdfgrouppath_batch.text()
            self.launch(batch_list, img_range, hdf_path, self.lineEdit_folderpath.text())
        
    ##Integration
    def single_launch(self):

        img_range = []
        # Making sure if the single mode is clicked, that the image interval will be 
        # passed for integration.
        if self.groupbox_manual_image.isChecked() == False:
            img_range.append('All')
        else:                
            if self.lineEdit_imginitial.text() == "" or self.lineEdit_imgfinal.text() == "":
                img_range.append('All')
            else:
                int_img_initial = int(self.lineEdit_imginitial.text())
                int_img_final = int(self.lineEdit_imgfinal.text())

                # check and correct the image interval indexes if necessary
				# it just works in single mode

                if int_img_initial > int_img_final:
                    temp = int_img_final 
                    int_img_final = int_img_initial 
                    int_img_initial = temp
                if int_img_initial<0:
                    int_img_initial = 0
                if int_img_final > self.NImg -1:
                    int_img_final = self.NImg -1
                if int_img_initial > self.NImg -1:
                    int_img_initial = self.NImg -1
               
                self.lineEdit_imginitial.setText(str(int_img_initial))
                self.lineEdit_imgfinal.setText(str(int_img_final))

                img_range.append(str(int_img_initial) + "-" + str(int_img_final))

        data_file = self.lineEdit_datafile.text()
        hdf_path = self.lineEdit_hdfgrouppath.text()

        try:
            folderpath = self.datafile_path
        except:
            folderpath = ''

        self.launch(data_file, img_range, hdf_path, folderpath)

    ##Integration
    def launch(self, datafile, imgrange, hdfpath, folderpath):
    
        self.chosenRangeLines()
        
	# Insert datafile content in a list

        if isinstance(datafile, list):
            datafile_list = datafile
        	
        else:
            datafile_list= []
            datafile_list.append(datafile)

        #For name label over the progress bar
        self.datafile_list_bar = datafile_list

        Continue_Integration = True
        for each_file in datafile_list:
            scan_valid = self.validator(self.maskfile_path, self.lineEdit_maskfile.text(), folderpath, each_file)
        	
            if scan_valid != 0:
                print("Scan is invalid and cannot be launched.")
                Continue_Integration = False
			
        if Continue_Integration == True:	
            # mask file path.
            maskfile =  self.maskfile_path + "/" +self.lineEdit_maskfile.text()
            # spline file path.
            self.splinefile = self.lineEdit_splinefile.text()

            # azimuth range.
            azimuthinitial = self.lineEdit_azimuthinitial.text()#Restricao -180 a +180
            azimuthfinal = self.lineEdit_azimuthfinal.text()
            
            # q range.
            qrange_unit = self.radio_qrange()
            qrangeinitial = self.lineEdit_qrangeinitial.text()
            qrangefinal = self.lineEdit_qrangefinal.text()

            # polarization.
            polarization = self.radio_pol()
            if polarization == 'None':
                polarization = None

            # error model.
            error_model = self.radio_err()

            # qbins and normalization factor.
            qbins = self.lineEdit_qbins.text()
            normfactor = self.lineEdit_normfactor.text()

            # solid angle checkbox.
            if self.checkBox_solidangcorr.isChecked() == True:
                solidangle = self.checkBox_solidangcorr.isChecked()
            else:
                solidangle = None

            # poni file checkbox.
            if self.groupBox_ponifile.isChecked() == True:

                ponifile = self.lineEdit_ponifile.text()

                sampdetdist = self.poni_geo._dist
                xcenter = self.poni_geo._poni2
                ycenter = self.poni_geo._poni1
                xsize = self.poni_geo.detector.getPyFAI()['pixel2']*1E+06
                ysize = self.poni_geo.detector.getPyFAI()['pixel1']*1E+06
                tilt = self.poni_geo._rot1
                tiltplan = self.poni_geo._rot2
                tilt3 = self.poni_geo._rot3
                wave = self.poni_geo._wavelength*1E+10

                self.splinefile = None

            else:
                ponifile = None
                sampdetdist = self.lineEdit_sampdetdist.text()
                xcenter = self.lineEdit_xcenter.text()
                ycenter = self.lineEdit_ycenter.text()
                xsize = self.lineEdit_xsize.text()
                ysize = self.lineEdit_ysize.text()
                tilt = self.lineEdit_tilt.text()
                tiltplan = self.lineEdit_tiltplan.text()
                tilt3 = None
                wave = self.lineEdit_wave.text()
                if self.groupBox_spline.isChecked() == True:
                    self.splinefile = self.lineEdit_splinefile.text()
                else:
                    self.splinefile = None

            #If the variables are empty it is because the user didn't write in the fields;
            #If the variables are None it is because that field wont be considered for the analysis;

            # Calling the global var HDF_FOLDER and DAT_FOLDER to inside the class.
            global HDF_FOLDER
            global DAT_FOLDER

            integrated_folder_value = self.folderCheck(HDF_FOLDER, False)

            if integrated_folder_value == 1:# 1 if invalid
                os.system("mkdir " + HDF_FOLDER)
                os.system("mkdir " + DAT_FOLDER)
            else:
                dat_folder_value = self.folderCheck(DAT_FOLDER, False)
                if dat_folder_value == 1:
                    os.system("mkdir " + DAT_FOLDER)

            # Params dictionary that feed the integration.
            self.dict_params = {"folderpath":folderpath,"datafile":datafile_list,"hdfpath":hdfpath,"maskfile":maskfile,
            "imgrange":imgrange,"azimuthinitial":azimuthinitial,
            "azimuthfinal":azimuthfinal,"qrange_unit":qrange_unit,"qrangeinitial":qrangeinitial,
            "qrangefinal":qrangefinal,"polarization":polarization,"error_model":error_model,"qbins":qbins,
            "normfactor":normfactor,"solidangle":solidangle,"ponifile":ponifile,"sampdetdist":sampdetdist,"xcenter":xcenter,
            "ycenter":ycenter,"xsize":xsize,"ysize":ysize,"tilt":tilt,"tiltplan":tiltplan,"tilt3":tilt3 ,"wave":wave,"splinefile":self.splinefile}

            self.hdf_export_path = folderpath# Temp folder for exporting hdf files
            
            self.deleted_curves_idx =[]
            #Thread
            # Initializing the worker thread.
            #self.worker = WorkerThread(self.dict_params, self.pushButton_stop, self.flip_msk)
            self.worker= WorkerThread(self.dict_params, self.pushButton_stop, self.pushButton_stop_batch, self.flip_msk)
            self.worker.start()
            self.worker.update_progress.connect(self.evt_update_progress) 
            self.worker.plot_data_list.connect(self.plot_tab)

            #Important for hdf construction. HDF was automatically saved upon qthread was finished
            self.worker.finished.connect(self.evt_worker_finished)#Catching the finished signal
   
    ##Thread      
    def update_bar(self, progress):
        # Method that updates the progress bar.
        self.pbar.setValue(progress)  

    ##Thread
    def stopBtnFunc(self):
        # Method that stops the thread loop.
        self.worker.stop()

    ##Thread
    def evt_worker_finished(self):
        # Not used because now the hdfs are saved only upon clicking save,
        # not immediately after the qthread has finished.

        #print('evt_worker_finished')
        #QMessageBox.information(self,"Done!", "Worker thread complete")
        pass
        
    ##Thread
    def evt_update_progress(self,val):
            # Both bars updates simultaneously regardless of the mode - single or batch.
            
            # Just set the only name (single file mode).
            self.label_filename.setText(self.datafile_list_bar[val[1]])
            # Single file mode pbar.
            self.pbar.setValue(val[0])

            # Set the names from datafile (batch mode).
            self.label_filename_batch.setText(self.datafile_list_bar[val[1]])
            # Batch file mode pbar.
            self.pbar_batch.setValue(val[0])

    ##Integration
    def radio_err(self):
        # Method to verify the chosen error models.
        status_radio_poissonerr = self.radio_poissonerr.isChecked()
        status_radio_azimutherr = self.radio_azimutherr.isChecked()

        if status_radio_poissonerr == True:
            chosen_radio = 'poisson'
        elif status_radio_azimutherr == True:
            chosen_radio = 'azimuthal'
        else:
            pass
        return chosen_radio

    ##Integration
    def radio_pol(self):
        # Method to verify the chosen polarization.

        status_radio_vertpol = self.radio_vertpol.isChecked()
        status_radio_circpol = self.radio_circpol.isChecked()
        status_radio_horzpol = self.radio_horzpol.isChecked()
        status_radio_nonepol = self.radio_nonepol.isChecked()

        if status_radio_vertpol == True:
            chosen_radio = '-1'
        elif status_radio_circpol == True:
            chosen_radio = '0'
        elif status_radio_horzpol == True:
            chosen_radio = '1'
        elif status_radio_nonepol == True:
            chosen_radio = 'None'
        else:
            pass

        return chosen_radio

    ##Integration
    def radio_qrange(self):
        # Method to verify the chosen metric.
        status_radio_qangs = self.radio_qangs.isChecked()
        status_radio_qnano = self.radio_qnano.isChecked()
        status_radio_q2th = self.radio_q2th.isChecked()
        status_radio_rmm = self.radio_rmm.isChecked()

        if status_radio_qangs == True:
            chosen_radio = 'q_A^-1'
        elif status_radio_qnano == True:
            chosen_radio = 'q_nm^-1'
        elif status_radio_q2th == True:
            chosen_radio = '2th_deg'
        elif status_radio_rmm == True:
            chosen_radio = 'r_mm'
        else:
            pass

        return chosen_radio


    ##Integration
    def questionPopUpBox(self, message):

        qm = QMessageBox
        ret = qm.question(self,'', message, qm.Yes | qm.No)
        if ret == qm.Yes:
            chosen = "Yes"
        else:
            chosen = "No"

        return chosen

    ##Integration
    def checkMaskFolder(self, integrated_folder, mask_folder):

        integrated_folder_value = self.folderCheck(integrated_folder, False)
        if integrated_folder_value == 1:# 1 if invalid
            os.system("mkdir " + integrated_folder)
        
        msk_folder_value = self.folderCheck(mask_folder, False)
        if msk_folder_value == 1:
            os.system("mkdir " + mask_folder)

    ##Integration
    def mskRotation(self, filename):
        # Flipping the .msk mask if it was done with fit2d.
        base_filename = os.path.basename(filename)
        only_name, file_extension = os.path.splitext(base_filename)
        self.flip_msk = False
        if file_extension == '.msk':
            chosen = self.questionPopUpBox("Was the mask done with Fit2D?\nIf so a new mask will be saved flipped in .npy format at the Integrated folder in home.")
            if chosen == "Yes":
                self.flip_msk = True
                global HDF_FOLDER
                global DAT_FOLDER
                global MSK_FOLDER

                self.checkMaskFolder(HDF_FOLDER, MSK_FOLDER)

                img_fabio = fabio.open(filename)
                data_fabio = img_fabio.data
                flipped = np.flipud(data_fabio)

                flipped_filename = 'flipped_' + only_name + '.npy' 
                flipped_msk_path = MSK_FOLDER
                np.save(flipped_msk_path + '/' + flipped_filename, flipped)
                
                #self.maskfile_path = flipped_msk_path
                #self.lineEdit_maskfile.setText(flipped_filename)
            else:
                #self.maskfile_path, filename= os.path.split(filename)
                #self.lineEdit_maskfile.setText(filename)
                pass
        else:
            pass
                  
        self.maskfile_path, filename= os.path.split(filename)
        self.lineEdit_maskfile.setText(filename)

    #def getImage size = self.pyfai_poni.Hdf_Size(filename,hdf_group)

    ##Integration

    def getHdfSize(self, filename):
		# Check if the hdf file is readable and determine the
		# number of images. Just for single mode.

        try:
            read_bool = self.hdf_read_check(filename)
            hdf_group = self.lineEdit_hdfgrouppath.text()
            self.NImg =  self.pyfai_poni.Hdf_Size(filename, hdf_group)   
            self.pyfai_poni.get_Images_number(self.NImg)             
        except Exception as e:
            print(e)
            self.popupbox('Could not read the hdf file! Invalid file path or group')

    def getFilename(self, file):
        # Method to display gui for choosing the files.
        folder = self.lineEdit_folderpath.text()#WorkFolder
        
        if file == 'datafile':
            #filename, _ = QFileDialog.getOpenFileName(self, 'Select File', folder, "HDF5 *.hdf5;;npy *.npy")
            filename, _ = QFileDialog.getOpenFileName(self, 'Select File', folder, "HDF5, H5, CXI, NPY, TIF (*.hdf5 *.h5 *.cxi *.npy *.tif)")
            self.getHdfSize(filename)

            self.datafile_path, filename= os.path.split(filename)
            self.lineEdit_datafile.setText(filename)

        elif file == 'maskfile':
            filename, _ = QFileDialog.getOpenFileName(self, 'Select File', folder,  "Numpy, MSK (*.npy *.msk)")
            self.mskRotation(filename)

        elif file == 'ponifile':
            filename, _ = QFileDialog.getOpenFileName(self, 'Select File', folder, "PONI *.poni")
            self.lineEdit_ponifile.setText(filename)
            self.poniLoader()
        elif file == 'splinefile':
            filename, _ = QFileDialog.getOpenFileName(self, 'Open Plot File', folder, "Text Files *.txt")
            self.lineEdit_splinefile.setText(filename)


    def poniLoader(self):
        # Method that reads the poni file with pyFAI and write its values in GUI.
        poni_filename = self.lineEdit_ponifile.text()
        
        filename, file_extension = os.path.splitext(poni_filename)
        if os.path.isfile(poni_filename) == False or file_extension != '.poni':

            self.popupbox("Please check if filepath is correct and if the extension is '.poni'")

            self.lineEdit_sampdetdist.setText('')
            self.lineEdit_xcenter.setText('')
            self.lineEdit_ycenter.setText('')
            self.lineEdit_xsize.setText('')
            self.lineEdit_ysize.setText('')
            self.lineEdit_tilt.setText('')
            self.lineEdit_tiltplan.setText('')
            self.lineEdit_tilt3.setText('Nan') #Tilt3 (rot3) is not defined without poni
            self.lineEdit_wave.setText('')
        else:
            self.poni_geo = self.pyfai_poni.Load_geometry_poni(poni_filename)

            self.lineEdit_sampdetdist.setText(str(self.poni_geo._dist))
            self.lineEdit_wave.setText(str('{0:.5f}'.format(self.poni_geo._wavelength*1E+10)))
            self.lineEdit_ycenter.setText(str('{0:.5f}'.format(self.poni_geo._poni1)))
            self.lineEdit_xcenter.setText(str('{0:.5f}'.format(self.poni_geo._poni2)))
            self.lineEdit_ysize.setText(str(round(self.poni_geo.detector.getPyFAI()['pixel1']*1E+06)))#In um
            self.lineEdit_xsize.setText(str(round(self.poni_geo.detector.getPyFAI()['pixel2']*1E+06)))
            self.lineEdit_tilt.setText(str(self.poni_geo._rot1))
            self.lineEdit_tiltplan.setText(str(self.poni_geo._rot2))
            self.lineEdit_tilt3.setText(str(self.poni_geo._rot3))
 
    ##Integration
    def search_choose_dir(self):

        """Open a dir browser and write the selected path on editFilepath."""
        try:
            ref_folder = self.lineEdit_folderpath.text()
        except:
            ref_folder = ''

        folder = QFileDialog.getExistingDirectory(
                    parent=self.pushButton_folderpath,
                    caption='Choose Work Folder',
                    directory=ref_folder)

        if folder is None or folder == '':
            return
        self.lineEdit_folderpath.setText(folder)
        

    ##Integration 
    def Check_string(self, Range_string):
        # Method used to check if the string used to slice the image interval is valid.
        characters = ['All',';','-']
        if not characters[0] in Range_string:
            if not any(char.isdigit() for char in Range_string):
                return False	
			
            else:
                for i in Range_string:
                    if not (any(j == i for j in characters)):
                        if i.isdigit() == False:
                            return False		
	
        return True

    ##Integration
    def onPoniGroupBoxToggled(self):
        # This method applies a hide and show effect as well as read only properties
        # upon checking or unchecking the groupbox for the poni.

        if self.groupBox_ponifile.isChecked():

            self.lineEdit_sampdetdist.setReadOnly(True)
            self.lineEdit_xcenter.setReadOnly(True)
            self.lineEdit_ycenter.setReadOnly(True)
            self.lineEdit_xsize.setReadOnly(True)
            self.lineEdit_ysize.setReadOnly(True)
            self.lineEdit_tilt.setReadOnly(True)
            self.lineEdit_tiltplan.setReadOnly(True)
            self.lineEdit_wave.setReadOnly(True)
            self.label_tilt3.setHidden(False)
            self.lineEdit_tilt3.setHidden(False)
            self.lineEdit_tilt3.setReadOnly(True)

       
            self.label_sampdetdist.setText(self.geom_labels[0][1])
            self.label_ycenter.setText(self.geom_labels[2][1])
            self.label_xcenter.setText(self.geom_labels[3][1])
            self.label_xsize.setText(self.geom_labels[4][1])
            self.label_ysize.setText(self.geom_labels[5][1])
            self.label_tilt.setText(self.geom_labels[6][1])
            self.label_tiltplan.setText(self.geom_labels[7][1])
            self.label_tilt3.setText(self.geom_labels[8][1])

        else:

            self.lineEdit_sampdetdist.setText('')
            self.lineEdit_xcenter.setText('')
            self.lineEdit_ycenter.setText('')
            self.lineEdit_xsize.setText('')
            self.lineEdit_ysize.setText('')
            self.lineEdit_tilt.setText('')
            self.lineEdit_tiltplan.setText('')
            self.lineEdit_tilt3.setText('')
            self.lineEdit_wave.setText('')

            self.lineEdit_sampdetdist.setReadOnly(False)
            self.lineEdit_xcenter.setReadOnly(False)
            self.lineEdit_ycenter.setReadOnly(False)
            self.lineEdit_xsize.setReadOnly(False)
            self.lineEdit_ysize.setReadOnly(False)
            self.lineEdit_tilt.setReadOnly(False)
            self.lineEdit_tiltplan.setReadOnly(False)
            self.lineEdit_wave.setReadOnly(False)

            self.label_tilt3.setHidden(True)
            self.lineEdit_tilt3.setHidden(True)

            self.label_sampdetdist.setText(self.geom_labels[0][0])
            self.label_ycenter.setText(self.geom_labels[2][0])
            self.label_xcenter.setText(self.geom_labels[3][0])
            self.label_xsize.setText(self.geom_labels[4][0])
            self.label_ysize.setText(self.geom_labels[5][0])
            self.label_tilt.setText(self.geom_labels[6][0])
            self.label_tiltplan.setText(self.geom_labels[7][0])
            self.label_tilt3.setText(self.geom_labels[8][0])

    ##Lists
    def onFolderChangeUpdtList(self):
        # This method refreshes the list widgets, automaticaly, upon changing the text of the folderpath.
        self.lineEdit_folderpath.textChanged.connect(self.refreshLists)

    ##Lists
    def addFullAllRange(self):
        # This method adds the string "All" to all items and make them editable.
        img_range = 'All'
        elements_right_list = self.listWidgetRight.count()
        for i in range(elements_right_list):
            item = QtWidgets.QListWidgetItem()
            item.setText(img_range)
            item.setFlags(item.flags() | QtCore.Qt.ItemIsEditable)
            self.listWidgetRange.addItem(item)

    ##Lists
    def removeFullAllRange(self):
        # This method clear all items in the qlist widget.
        self.listWidgetRange.clear()

    ##Lists
    def addSingleAllRange(self):
        # This method adds the string "All" to a qlist item make them editable.
        img_range = 'All'
        item = QtWidgets.QListWidgetItem()
        item.setText(img_range)
        item.setFlags(item.flags() | QtCore.Qt.ItemIsEditable)
        self.listWidgetRange.addItem(item)

    ##Lists
    def removeSingleAllRange(self,row):
        # This method removes the specified item.
        self.listWidgetRange.takeItem(row)

    ##Lists
    def listFiles(self):

        # This method loads files of a workfolder and display them sorted by the latest and just
        #  their basename.

        Extensions = ['hdf5', 'h5', 'cxi', 'npy', 'tif']
        for ext in Extensions:
            path = self.lineEdit_folderpath.text() + '/'
            file_list = sorted(glob.glob(path + "*." + ext), key=os.path.getmtime, reverse = True)
        
            for i in range(len(file_list)):
                    file_list_display = os.path.basename(file_list[i])
                    self.listWidgetLeft.addItem(file_list_display)

    ##Lists
    def refreshLists(self):
        # This method refreshs the qlists by cleaning them and reloading the files.
        self.listWidgetLeft.clear()
        self.listWidgetRight.clear()
        self.listWidgetRange.clear()
        self.listFiles()
        
    ##Lists
    def chosenRangeLines(self):
        # This method gets a list with all the image ranges.
        listWidgetRange_length = self.listWidgetRange.count() 
        image_range_list = [0] * listWidgetRange_length
        for i in range (listWidgetRange_length):
            image_range_list[i] = self.listWidgetRange.item(i).text()
      
        return(image_range_list)

    ##Lists
    def chosenBatchFiles(self):
        # This method gets a list with all the chosen files.
        batch_list_length = self.listWidgetRight.count()
        batch_files_list = [0] * batch_list_length
        for i in range (batch_list_length):
            batch_files_list[i] = self.listWidgetRight.item(i).text()
        return(batch_files_list)

    ##Lists
    def setButtonConnections(self):
        # This method set the connections for dynamic lists in batch mode tab.

        self.listWidgetLeft.itemSelectionChanged.connect(self.updateButtonStatus)
        self.listWidgetRight.itemSelectionChanged.connect(self.updateButtonStatus)

        self.button_right.clicked.connect(self.buttonAddClicked)
        self.button_left.clicked.connect(self.buttonRemoveClicked)
        self.button_allright.clicked.connect(self.buttonAddAllClicked)
        self.button_allleft.clicked.connect(self.buttonRemoveAllClicked)

        self.button_up.clicked.connect(self.buttonUpClicked)
        self.button_down.clicked.connect(self.buttonDownClicked)

        self.btn_refresh_lists.clicked.connect(self.refreshLists)


    ##Lists
    def setItemDoubleClicked(self):
        # This method gives the property to add or remove items from list by ouble clicking.

        self.listWidgetLeft.itemDoubleClicked.connect(self.buttonAddClicked)
        self.listWidgetRight.itemDoubleClicked.connect(self.buttonRemoveClicked)

    ##Lists
    def buttonAddClicked(self):
        # This method is meant for adding files into the chosen files qlist
        ##For dynamic lists
        row = self.listWidgetLeft.currentRow()
        rowItem = self.listWidgetLeft.takeItem(row)
        self.listWidgetRight.addItem(rowItem)

        ##Adding the Range List here
        self.addSingleAllRange()

    ##Lists
    def buttonRemoveClicked(self):
        # This method is meant for removing files from the chosen files qlist.

        row = self.listWidgetRight.currentRow()
        rowItem = self.listWidgetRight.takeItem(row)
        self.listWidgetLeft.addItem(rowItem)

        # Adding the Range List here
        self.removeSingleAllRange(row)

    ##Lists
    def addPartialAllRange(self):
        # This method adds the "All" string for the range qlist and make them editable.
        img_range = 'All'
        elements_left_list = self.listWidgetLeft.count()
        for i in range(elements_left_list):
            item = QtWidgets.QListWidgetItem()
            item.setText(img_range)
            item.setFlags(item.flags() | QtCore.Qt.ItemIsEditable)
            self.listWidgetRange.addItem(item)

    ##Lists
    def buttonAddAllClicked(self):
        # Method that adds all filenames from the left to right qlist.
        
        self.addPartialAllRange()
        for i in range(self.listWidgetLeft.count()):
            self.listWidgetRight.addItem(self.listWidgetLeft.takeItem(0))
        
    ##Lists
    def buttonRemoveAllClicked(self):
        # Method that removes all filenames from the right to left qlist.

        for i in range(self.listWidgetRight.count()):
            self.listWidgetLeft.addItem(self.listWidgetRight.takeItem(0))
        self.removeFullAllRange()

    ##Lists
    def buttonUpClicked(self):
        # Method that moves upward a filename in the qlist.
        rowIndex = self.listWidgetRight.currentRow()
        currentItem = self.listWidgetRight.takeItem(rowIndex)
        self.listWidgetRight.insertItem(rowIndex - 1, currentItem)
        self.listWidgetRight.setCurrentRow(rowIndex - 1)

        # Adding the Range List here for synchronized movement.
        self.listWidgetRange.setCurrentRow(rowIndex)#To highlight the row
        range_currentItem = self.listWidgetRange.takeItem(rowIndex)
        self.listWidgetRange.insertItem(rowIndex - 1, range_currentItem)
        self.listWidgetRange.setCurrentRow(rowIndex - 1)

    ##Lists
    def buttonDownClicked(self):
        # Method that moves downward a filename in the qlist.
        rowIndex = self.listWidgetRight.currentRow()
        currentItem = self.listWidgetRight.takeItem(rowIndex)
        self.listWidgetRight.insertItem(rowIndex + 1, currentItem)
        self.listWidgetRight.setCurrentRow(rowIndex + 1)

        # Adding the Range List here for synchronized movement.
        self.listWidgetRange.setCurrentRow(rowIndex)#To highlight the row
        range_currentItem = self.listWidgetRange.takeItem(rowIndex)
        self.listWidgetRange.insertItem(rowIndex + 1, range_currentItem)
        self.listWidgetRange.setCurrentRow(rowIndex + 1)

    ##Lists
    def updateButtonStatus(self):
        # Disable the directional buttons if following conditions are satisfied.
        self.button_up.setDisabled(not bool(self.listWidgetRight.selectedItems()) or self.listWidgetRight.currentRow() == 0)
        self.button_down.setDisabled(not bool(self.listWidgetRight.selectedItems()) or self.listWidgetRight.currentRow() == self.listWidgetRight.count() - 1)#Desabilita se o indice da lista for o ultimo
        self.button_right.setDisabled(not bool(self.listWidgetLeft.selectedItems()) or self.listWidgetLeft.count() == 0)
        self.button_left.setDisabled(not bool(self.listWidgetRight.selectedItems()) or self.listWidgetRight.count() == 0)

    ##Plot
    def init_pyplot_graph(self):
        # Initializing a blank plot area.
        layout = self.layout_toolbar
        
        self.canvas = FigureCanvas(plt.Figure(figsize=(self.fig_width, self.fig_height)))
        self.toolbar = NavigationToolbar(self.canvas, self)
        layout.addWidget(self.toolbar)
        layout.addWidget(self.canvas)
        font = {
            'weight': 'normal',
            'size': 16
        }
        matplotlib.rc('font', **font)
        return layout
    
    ##Plot
    def insert_ax(self):
        # Method to insert the plot axis.
        plt.clf()
        self.ax = self.canvas.figure.subplots()
        if  self.xScale_button.text() == "Linear X":
            self.ax.set_xscale('log')
        if  self.yScale_button.text() == "Linear Y":
            self.ax.set_yscale('log')
        if self.radial_unity == "q_A^-1":
            q_unity = "q (Å$^{-1}$)"
        if self.radial_unity == "q_nm^-1":
            q_unity = "q (nm$^{-1}$)"
        if self.radial_unity ==  "2th_deg":
            q_unity = "2θ (deg)"
        if self.radial_unity == "r_mm" :
            q_unity = "r (mm)"
        self.ax.set_xlabel(q_unity)
        self.ax.set_ylabel("Intensity (a. u.)")
        self.curve = []
        i=0
        
        for file_name in  self.Int_data.keys() :
            plot_temp, = self.ax.plot(self.Int_data[file_name][0],self.Int_data[file_name][1],
            color = (self.colors[self.C_index[i]][0]/255,self.colors[self.C_index[i]][1]/255,self.colors[self.C_index[i]][2]/255)) 
            self.curve.append(plot_temp) 
            i +=1
 
    ##Plot
    def Color_indexes(self, Nc):
        # Method to use custom RGB colors in the plot.
        # Array containing the color indexes.
        self.C_index = [0] * Nc
        ki = 0
        mt= 1
        colors_len = len(self.colors)
        for i in range(Nc):
        # If all the colors available in RGB_codes.py 
        # are stored, then the list is restarted from the first color.
            if ki + i > colors_len - 1:
                ki = - mt * colors_len
                mt += 1
            self.C_index[i] = ki + i  

    ##Plot
    def plot_tab(self, plot_data_list ):
        # This method is responsible for auto - plotting the integration results.
        #try:
           
        self.radial_unity = plot_data_list[0]

        # Int_data is updated accordingly with the plot data list (adds and deletion).
        self.Int_data = plot_data_list[1]

        self.N_curves = len(self.Int_data.keys())

        self.Color_indexes(self.N_curves)

        self.createLayout_scrollArea()

        try: 
            self.ax.remove()
            self.insert_ax()
            self.toolbar.update()
            self.canvas.draw()
        except:
            self.insert_ax()
    
        #except:
            #print('Error while trying to plot!')

    ##Plot
    def init_plot_buttons(self):
        # Initializing the plot related buttons.

        self.xScale_button.clicked.connect(self.update_xscale)
        self.yScale_button.clicked.connect(self.update_yscale)
        self.del_curves_button.clicked.connect(self.delete_curves)
        self.export_curves_button.clicked.connect(self.hdf_export_dir)
        self.select_plot_checkbox.stateChanged.connect(self.select_deselect_curves)

    ##Plot
    def update_xscale(self):
        # Method that changes the horizontal x scale between log and linear.

        if self.xscale:
            self.ax.set_xscale('log')
            self.xscale = False
        else:
            self.ax.set_xscale('linear')
            self.xscale = True
        self.canvas.draw()
        
        # Updating button names.
        if self.xScale_button.text() == 'Log X':
            self.xScale_button.setText('Linear X')
        else:
            self.xScale_button.setText('Log X')


    ##Plot
    def update_yscale(self):
        # Method that changes the vertical y scale between log and linear.

        if self.yscale:
            self.ax.set_yscale('log')
            self.yscale = False
        else:
            self.ax.set_yscale('linear')
            self.yscale = True
        self.canvas.draw()

        # Updating button names.
        if self.yScale_button.text() == 'Log Y':
            self.yScale_button.setText('Linear Y')
        else:
            self.yScale_button.setText('Log Y')

    ##Plot
    def delete_curves(self):
        # Method to delete the curves in plot tab and in Int_data var.

        unchecked = []
        global Int_data
        for i in range(len(self.item)):
            if self.item[i].isChecked() == False and self.item[i].isHidden() == False:
                unchecked.append(self.item[i].text())
                self.item[i].hide()
                self.deleted_curves_idx.append(i)
                
        for key in unchecked:

            del Int_data[key]

        self.update_alpha()

    ##Plot
    def select_deselect_curves(self):
        # Method that quickly select or deselect the curves qcheckboxes
        # and updates the appearance (alpha).
            
        for i in range(len(self.item)):# Tricky optimisation.
            self.item[i].disconnect()

            if self.select_plot_checkbox.isChecked():
                self.item[i].setChecked(True)
            else:
                self.item[i].setChecked(False)

            self.item[i].stateChanged.connect(self.update_alpha)
        self.update_alpha()


    def createLayout_scrollArea(self):
        # Creating scroll area for docking the curve qcheckboxes.
        
        self.scrollarea.setFixedWidth(250)
        self.scrollarea.setWidgetResizable(True)
        widget = QWidget()
        self.scrollarea.setWidget(widget)
        self.layout_SArea = QVBoxLayout(widget)
        self.layout_SArea.addWidget(self.createLayout_group(self.N_curves))
        self.layout_SArea.addStretch(1)


    def createLayout_group(self, number):
        # This method creates the qcheckboxes for the curves.

        sgroupbox = QGroupBox("Display", self)
        layout_groupbox = QVBoxLayout(sgroupbox)
        self.item = [0] * number
        i=0
        for key in self.Int_data.keys():
            self.item[i] = QCheckBox(key, sgroupbox)
            self.item[i].setStyleSheet("color:rgb(" + str(self.colors[self.C_index[i]][0]) +","+ str(self.colors[self.C_index[i]][1]) + ","+str(self.colors[self.C_index[i]][2])+");")
            self.item[i].setChecked(True)
            self.item[i].stateChanged.connect(self.update_alpha)
            layout_groupbox.addWidget(self.item[i])
            i += 1
        layout_groupbox.addStretch(1)
        return sgroupbox

    ##Plot
    def update_alpha(self):
        # This method checks if the curve checkbox is selected or not and applies the 
        # propper alpha (transparency) property.

        for i in range(len(self.item)):
          
            if self.item[i].isChecked() == False or i in self.deleted_curves_idx:
        		
                self.curve[i].set_alpha(0)
            else:
                if i not in  self.deleted_curves_idx:
                    self.curve[i].set_alpha(1)
        self.canvas.draw()

    ##Output
    def retrieveFilenames(self,Img_names):
        # Method that retrieves the filename from the incremented filename in Int_data.
        # As Int_data is updated deleting or doing new integrations, it is necessary to extract the 
        # unique names useful for hdf exportation.
        global Int_data
                
        cut_names = [0] * len(Img_names)
        for i in range(len(Img_names)):
            img_tmp = Img_names[i]
            cut_names[i] = img_tmp[: img_tmp.rfind('_')]
       
        names_tmp =[]
        incremented_names =[]
        unique_names = list(set(cut_names))

        list_temp = []
        for i in range(len(unique_names)):
            for key,value in Int_data.items():
                if key[: key.rfind('_')] == unique_names[i]:
                 
                    names_tmp.append(key)

            incremented_names.append(names_tmp)
            names_tmp = []
        values_dict = {}
       
        for i in range(len(incremented_names)):
            list_temp = []
            for j in range(len(incremented_names[i])):
           
                list_temp.append(Int_data[incremented_names[i][j]])
            values_dict[unique_names[i]] =list_temp

        return values_dict, incremented_names,  unique_names

    ##Output
    def Filter_filenames(self):
        # Returns unique file names and positions in the main data dict.

        global Int_data
        curves_list = np.array(list(Int_data.keys()))
        N = len(curves_list)
        cut_list = np.array([curves_list[i][0:-10] for i in range(N)])
        unique_names = np.unique(cut_list)
        N_names = unique_names.shape[0]
       
        Names_indexes = []
        for i in range(N_names):
            Names_indexes.append(np.where(cut_list == unique_names[i])[0])
            
        return unique_names, Names_indexes 

    #Output
    def Output_to_Hdf(self, save_path):
        # This method export the integrated results and used parameters in HDF file.

        # Gathering the image names from Int_data
        global Int_data
        Img_names = list(Int_data.keys())

        # Gathering the remained unique names, incremented names and the exportation dictionary for the data results.
        export_dict, inc_names, unique_names = self.retrieveFilenames(Img_names)
        # Pre-allocating the headers
        data_headers = [0] * 22
        # Filling the first 13 header names
        data_headers[0:12] = ["Image Names", "HDF Group", "Azimuth Min (deg)", "Azimuth Max (deg)", "X Unit", "X Min", "X Max",
        "Polarization", "Error Model", "N Bins", "Norm Factor", "Solid Angle Correction", "Poni File"]

        # For saving dat file.
        headers_table = {}
        values_table = {} 
        q_table = {}
        I_table = {}
        std_table = {}

        for ii in range(len(unique_names)):
           
            data_values =  [list(row[3].values()) for row in list(export_dict[unique_names[ii]])] 
            data_types = []
      
            for img in range (len(data_values[0])):
                data_types.append(h5py.special_dtype(vlen=str))

            k =0 
            for each_list in data_values:
                # Getting the X Min and X Max for each image.
                each_list[8] = np.min(np.array(list(Int_data.values())[k][0]))
                each_list[9] = np.max(np.array(list(Int_data.values())[k][0]))
                               
                # Dropping folder name.
                each_list.pop(0)
                # Dropping filename.
                each_list.pop(0)
                # Dropping maks full path.
                each_list.pop(1)
                # Dropping image range.
                each_list.pop(1)
                # Adding incremented image name.
                each_list.insert(0,inc_names[ii][k])
                k+=1

            # Removing data types to adjust its size with size 22 of data_values now.
            data_types.pop(0)
            data_types.pop(0)
            data_types.pop(1)
            data_types.pop(1)

            # Filling the rest of the data_headers with known names from GUI.
            data_headers[13] =  self.label_sampdetdist.text()
            data_headers[14] =  self.label_xcenter.text()
            data_headers[15] =  self.label_ycenter.text()
            data_headers[16] =  self.label_xsize.text()
            data_headers[17] =  self.label_ysize.text()
            data_headers[18] =  self.label_tilt.text()
            data_headers[19] =  self.label_tiltplan.text()
            data_headers[20] =  self.label_tilt3.text()
            data_headers[21] =  self.label_wave.text()
            data_headers[22] =  "spline"
            
            # Casting all the data_types to hdf special string format.
            for img in range (len(data_values[0])):
                data_types.append(h5py.special_dtype(vlen=str))
                
            # Casting all the variables to string format. Afterwards some will be float.
            for i in range(len(data_values)): 
                for j in range(len(data_values[0])):
                    data_values[i][j] = str(data_values[i][j])

                # Converting some variables in more readable strings.
                if data_values[i][7] == '0':
                    data_values[i][7] ='circular'
                elif data_values[i][7] == '-1':
                    data_values[i][7] = 'vertical'
                elif data_values[i][7] == '1':
                    data_values[i][7] = 'horizontal'
                else:
                    pass
            
                if data_values[i][11] == "True":
                    data_values[i][11] = "yes"
                else:
                    data_values[i][11] = "no"
            
            # Casting specific variables into float.
            float_list = [2,3,5,6,9,10,13,14,15,16,17,18,19,20,21]

            for i in range(len(data_values)):
                if  data_values[i][20] == "None":
                    data_values[i][20] =0
                for j in float_list:
                    data_values[i][j] = float(data_values[i][j])
            
            # Casting specific data_types into float.
            for i in float_list:
                data_types[i] = float
            
            # Extracting the lists for the integration results: q, Int and std. 
            q = [list(row[0]) for row in list(export_dict[unique_names[ii]])]
            Int = [list(row[1]) for row in list(export_dict[unique_names[ii]])]
            std = [list(row[2]) for row in list(export_dict[unique_names[ii]])]
            
            # Creating specific data_values for the cases where poni is used or not (fit2d style).
            data_values_PONI = []
            data_values_FIT2D = []

            # Separating images integrated with poni of the fit2d style.
            kk = 0
            
            for iv in range(len(data_values)):
        
                if data_values[iv][12] == str(None):
                    data_values_FIT2D.append(data_values[iv])
                    data_values_FIT2D[kk].pop(20)
                    kk+=1
                else:
                    data_values_PONI.append(data_values[iv])
         
                 
            # Creating the export row for poni and fit2d types of outputs.
            if data_values_PONI:
                data_headers_PONI = ['Image Names', 'HDF Group', 'Azimuth Min (deg)', 'Azimuth Max (deg)', 'X Unit', 'X Min', 'X Max', 
            'Polarization', 'Error Model', 'N Bins', 'Norm Factor', 'Solid Angle Correction', 'Poni File', 'Samp-Det Distance (m)',
            'Poni2 (m)', 'Poni1 (m)', 'Pixel Size 2 (μm)', 'Pixel Size 1 (μm)', 'Rot1 (rad)', 'Rot2 (rad)', 'Rot3 (rad)',
            'Wavelength (Å)', 'spline']

                # For dat files.
                for img in range(len(inc_names[ii])):
                    headers_table[inc_names[ii][img]] =  data_headers_PONI
                    values_table[inc_names[ii][img]] = data_values_PONI[img]
                    q_table[inc_names[ii][img]] = q[img]
                    I_table[inc_names[ii][img]] = Int[img]
                    std_table[inc_names[ii][img]] = std[img]

                data_types_Poni = data_types
                ds_dt_PONI = np.dtype({'names':data_headers_PONI,'formats': data_types_Poni }) 
                # Making an array with mixed types.
                rec_arr_PONI = np.rec.fromarrays(list(map(list, zip(*data_values_PONI))), dtype=ds_dt_PONI)
                
            if data_values_FIT2D:
                data_headers_FIT2D = ['Image Names', 'HDF Group', 'Azimuth Min (deg)', 'Azimuth Max (deg)', 'X Unit', 'X Min', 'X Max', 
            'Polarization', 'Error Model', 'N Bins', 'Norm Factor', 'Solid Angle Correction', 'Poni File', 'Samp-Det Distance (m)', 
            'X-Center (px)', 'Y-Center (px)', 'X-Pixel Size (μm)', 'Y-Pixel Size (μm)', 'Tilt (dg)', 'Tilt Plan Rot (dg)', 
            'Wavelength (Å)', 'spline']
                # For dat files.
                for img in range(len(inc_names[ii])):
                    headers_table[inc_names[ii][img]] =  data_headers_FIT2D
                    values_table[inc_names[ii][img]] = data_values_FIT2D[img]
                    q_table[inc_names[ii][img]] = q[img]
                    I_table[inc_names[ii][img]] = Int[img]
                    std_table[inc_names[ii][img]] = std[img]

                data_types_Fit2D = data_types
                data_types_Fit2D.pop(21) 
                ds_dt_Fit2D = np.dtype({'names':data_headers_FIT2D,'formats': data_types_Fit2D })
                # Making an array with mixed types.
                rec_arr_Fit2D = np.rec.fromarrays(list(map(list, zip(*data_values_FIT2D))), dtype=ds_dt_Fit2D)
                
            # Making sure the folder wasn't erased by the user during the integration.
            global HDF_FOLDER
            global DAT_FOLDER
            integrated_folder_value = self.folderCheck(HDF_FOLDER, False)
            if integrated_folder_value == 1:# 1 if invalid
                os.system("mkdir " + HDF_FOLDER)
            else:
                dat_folder_value = self.folderCheck(DAT_FOLDER, False)
                if dat_folder_value == 1:
                    os.system("mkdir " + DAT_FOLDER)
      
            # Saving the results in hdf5.
            with h5py.File( save_path + "/" + unique_names[ii] + "_Integrated.hdf5", "w") as h5f :
                
                dset = h5f.create_group("Parameters")  
                if data_values_PONI:
                    dset.create_dataset("data_PONI", (len(data_values_PONI),), data=rec_arr_PONI)
                if data_values_FIT2D:
                    dset.create_dataset("data_Fit2D", (len(data_values_FIT2D),), data=rec_arr_Fit2D)
             
                fileg = h5f.create_group("Intensity data")
                for im in range(len(data_values)):
                    ds_dtB = np.dtype({'names':[data_values[im][4], "Intensity", "std"],'formats': [float,float,float] }) 
                    Int_temp = []
                    Int_temp.append(q[im])
                    Int_temp.append(Int[im])
                    Int_temp.append(std[im])
                    rec_arrB = np.rec.fromarrays(Int_temp, dtype=ds_dtB)
                    fileg.create_dataset(inc_names[ii][im], (len(q[im]),), data=rec_arrB)
             
            h5f.close()


        return headers_table, values_table, q_table, I_table, std_table

    def hdf_export_dir(self):

        global HDF_FOLDER
        global DAT_FOLDER
        
        try:
            headers_table, values_table, q_table, I_table, std_table = self.Output_to_Hdf(HDF_FOLDER)
            
            # All dictionaries have the same index keys (the incremented names).
            table_keys = list(headers_table.keys())
            
            for index in table_keys:
                
                # Dividing by tabs header and values. Too big horizontally.
                # headers_temp = '\t'.join(str(e) for e in headers_table[index])
                # values_temp = '\t'.join(str(e) for e in values_table[index])
                # numpy_headers = headers_temp + '\n' + values_temp + '\n' + 'q' + '\t' + 'Intensity' + '\t' + 'std'

                header_and_values_build = self.build_header(headers_table[index], values_table[index], 4)

                numpy_headers = header_and_values_build + '\n' + 'q' + '\t' + 'Intensity' + '\t' + 'std'

                column_data = np.column_stack([q_table[index], I_table[index], std_table[index]])

                save_name = DAT_FOLDER + '/' + str(index) + '.dat'
                np.savetxt(save_name, column_data, fmt="%s", delimiter = '\t', header = numpy_headers)

            print("saved")

            self.popupbox("HDF and Dat Files are Saved!\nCheck in Integrated folder at Home directory.")

        except Exception as e:
            self.popupbox("Error while saving the results." + "\n" + str(e))
            print(e)

    def build_header(self, names_list,values_list, var_per_line):

        header_var =""
        counter = 0
        N_strings = len(names_list)
        for i in range(N_strings):
            header_var += str(names_list[i]) + " = " + str(values_list[i]) + ", "
            counter +=1
            if counter == var_per_line:
                header_var += " \n"
                counter = 0
        return header_var


if __name__ == '__main__':


    app = QtWidgets.QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec_())
